# Generated by Django 3.2.20 on 2023-09-08 18:16

import re
from pathlib import Path as Pathlib

from django.db import migrations
from django.utils import timezone

yearRegex = re.compile(r"20\d{2}\D?.*$")
dvdRegex = re.compile(r"[A-Z]{2,}.*$")
formatRegex = re.compile(r"\b(xvid|avi|XVID|AVI)+\b")
punctuationRegex = re.compile(r"[^a-zA-Z0-9]+")


def path_display_name(obj):
    return obj.override_display_name or path_short_name(obj).replace(".", " ").title()


def path_short_name(obj):
    return obj.localpathstr.rpartition("/")[-1]


def file_display_name(obj):
    pass


def file_raw_search_string(obj):
    searchStr = obj.override_filename or obj._searchString or get_search_term(obj)
    return searchStr


def get_search_term(obj):
    if obj.path.is_movie:
        searchTerm = obj.filename
    else:
        searchTerm = obj.path.localpathstr.rpartition("/")[-1]
    searchTerm = yearRegex.sub("", searchTerm)
    searchTerm = dvdRegex.sub("", searchTerm)
    searchTerm = formatRegex.sub("", searchTerm)
    searchTerm = punctuationRegex.sub(" ", searchTerm)
    searchTerm = searchTerm.strip()

    return searchTerm


def file_short_name(obj):
    if obj.override_filename:
        return obj.override_filename

    if obj.filenamescrapeformat is None or obj.filenamescrapeformat.useSearchTerm:
        name = file_raw_search_string(obj)
    else:
        nameRegex = re.compile(obj.filenamescrapeformat.nameRegex).findall(obj.filename)
        name = nameRegex and nameRegex[0] or None
    return (
        name
        and (
            obj.filenamescrapeformat
            and obj.filenamescrapeformat.subPeriods
            and name.replace(".", " ").replace("-", " ").title()
            or name
        ).strip()
        or obj.filename
    )


def file_season(obj):
    if obj.override_season:
        return obj.override_season
    else:
        if not obj.filenamescrapeformat:
            return None

        seasonRegex = re.compile(obj.filenamescrapeformat.seasonRegex).findall(
            obj.filename
        )
        season = seasonRegex and seasonRegex[0] or None
    scraped_season = season and (season.isdigit() and season.zfill(2) or None) or None
    return int(scraped_season) if scraped_season else None


def file_episode(obj):
    if obj.override_episode:
        return obj.override_episode
    else:
        if not obj.filenamescrapeformat:
            return None

        episodeRegex = re.compile(obj.filenamescrapeformat.episodeRegex).findall(
            obj.filename
        )
        episode = episodeRegex and episodeRegex[0] or None
    scraped_episode = (
        episode and (episode.isdigit() and episode.zfill(2) or None) or None
    )
    return int(scraped_episode) if scraped_episode else None


def forward(apps, schema_editor):
    TV = apps.get_model("mediaviewer", "TV")
    Movie = apps.get_model("mediaviewer", "Movie")
    Path = apps.get_model("mediaviewer", "Path")
    File = apps.get_model("mediaviewer", "File")
    MediaPath = apps.get_model("mediaviewer", "MediaPath")
    MediaFile = apps.get_model("mediaviewer", "MediaFile")
    Poster = apps.get_model("mediaviewer", "Poster")
    PosterFile = apps.get_model("mediaviewer", "PosterFile")
    Comment = apps.get_model("mediaviewer", "Comment")
    UserComment = apps.get_model("mediaviewer", "UserComment")

    tv_path_qs = Path.objects.filter(is_movie=False)

    for path in tv_path_qs:
        if not path.file_set.exists():
            continue

        if not MediaPath.objects.filter(_path=path.localpathstr).exists():
            obj, created = TV.objects.get_or_create(
                name=path_display_name(path), defaults=dict(finished=path.finished)
            )
            if created:
                date_created = (
                    path.file_set.filter(datecreated__isnull=False)
                    .order_by("-datecreated")
                    .values_list("datecreated", flat=True)
                    .first()
                )
                obj.date_created = date_created or timezone.now()
                obj.save()

                poster_file = PosterFile.objects.get(path=path)
                path_imdb = (
                    path.imdb_id
                    if path.imdb_id and path.imdb_id.lower() != "none"
                    else ""
                )
                poster_file_tmdb = (
                    poster_file.tmdb_id
                    if poster_file.tmdb_id and poster_file.tmdb_id.lower() != "none"
                    else ""
                )
                poster = Poster.objects.create(imdb=path_imdb, tmdb=poster_file_tmdb)
                obj.poster = poster
                obj.save()

            mp, created = MediaPath.objects.get_or_create(
                _path=path.localpathstr, defaults=dict(tv=obj)
            )
            if path.skip:
                mp.skip = True
                mp.save()

        for file in path.file_set.filter(hide=False):
            mf = MediaFile.objects.create(
                media_path=mp,
                filename=file.filename,
                display_name=file._display_name,
                season=file_season(file),
                episode=file_episode(file),
                scraper=file.filenamescrapeformat,
                hide=file.hide,
                size=file.size,
            )
            # auto_now fields must be set after object creation
            mf.date_created = file.datecreated
            mf.date_edited = file.dateedited
            mf.save()

            poster_file = (
                PosterFile.objects.filter(file=file).order_by("tmdb_id").first()
            )
            file_imdb = (
                file.imdb_id if file.imdb_id and file.imdb_id.lower() != "none" else ""
            )
            poster_file_tmdb = (
                poster_file.tmdb_id
                if poster_file.tmdb_id and poster_file.tmdb_id.lower() != "none"
                else ""
            )
            poster = Poster.objects.create(imdb=file_imdb, tmdb=poster_file_tmdb)
            mf.poster = poster
            mf.save()

            for uc in UserComment.objects.filter(file=file):
                Comment.objects.create(media_file=mf, user=uc.user, viewed=uc.viewed)

    movie_file_qs = (
        File.objects.filter(path__is_movie=True)
        .select_related("path", "filenamescrapeformat")
        .exclude(hide=True)
    )

    for movie_file in movie_file_qs:
        movie = Movie.objects.create(
            name=file_short_name(movie_file),
            finished=movie_file.finished,
        )
        movie.date_created = movie_file.datecreated
        movie.date_edited = movie_file.dateedited
        movie.save()

        path = Pathlib(movie_file.path.localpathstr) / movie_file.filename
        mp = MediaPath.objects.create(
            _path=str(path), skip=movie_file.hide, movie=movie
        )

        movie_file_imdb = (
            movie_file.imdb_id
            if movie_file.imdb_id and movie_file.imdb_id.lower() != "none"
            else ""
        )
        poster_file = (
            PosterFile.objects.filter(file=movie_file).order_by("tmdb_id").first()
        )
        poster_file_tmdb = (
            poster_file.tmdb_id
            if poster_file.tmdb_id and poster_file.tmdb_id.lower() != "none"
            else ""
        )
        poster = Poster.objects.create(imdb=movie_file_imdb, tmdb=poster_file_tmdb)
        movie.poster = poster
        movie.save()

        for uc in UserComment.objects.filter(file=movie_file):
            Comment.objects.create(movie=movie, user=uc.user, viewed=uc.viewed)


def clean_up_old_objects(apps, schema_editor):
    DownloadToken = apps.get_model("mediaviewer", "DownloadToken")
    DownloadToken.objects.all().delete()


class Migration(migrations.Migration):
    dependencies = [
        ("mediaviewer", "0048_auto_20230929_0836"),
    ]

    operations = [
        migrations.RunPython(forward),
        migrations.RunPython(clean_up_old_objects),
    ]
